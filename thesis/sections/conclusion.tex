\chapter{Fazit und Ausblick}\label{ch:conclusion}
Im Rahmen dieser Arbeit konnte gezeigt werden, dass die von Altschuler und Williams vorgeschlagene Methode~\parencite{altschuler} grundsätzlich geeignet ist, Zahlen in ihre Primfaktoren zu zerlegen. \\
Es konnte das Laufzeitverhalten $\mathcal{O}\left(n^5\cdot N_a \cdot N_c\right)$ eines einzelnen Zerlegungsschrittes mit Hilfe von Simulationen bestätigt werden. Dies deutet darauf hin, dass $\mathcal{O}\left(n^4\cdot N_a\cdot N_c\right)$. Um dies zu zeigen könnten die benötigten Schritte gezählt werden. Außerdem konnte der Einfluss der Boltzmann-Konstanten und damit der Energieskala auf die Erfolgsrate und die Laufzeit untersucht werden. Mit den Erkenntnissen aus der Simulation ist es möglich, eine automatische Abschätzung von $k_\mathrm{B}$ in Abhängigkeit der Zahlenlänge vorzunehmen. \\
Das Verfahren bietet noch Möglichkeiten für weitere Untersuchungen. So könnte untersucht werden, wie sich Erfolgsrate und Laufzeit entwickeln, wenn zu kleine Zahlen $N_a$ und $N_c$ gewählt werden und somit zunächst nur wenige Programmdurchläufe eine erfolgreiche Zerlegung liefern. \\
Außerdem wurde ausschließlich die quadratische Energiedefinition getestet. Der genaue Einfluss der Energiefunktion auf die Laufzeit und die Erfolgsrate wurde nicht untersucht. Dabei könnte versucht werden, Funktionen zu ermitteln, die eine schnellere Konvergenz der Faktoren $A$ und $B$ gegen die Faktoren von $N$ bewirken.  \\
Bei der Implementierung des Programmes \textit{factorize} könnte man noch erweiterte Methoden zum Test, ob die erhalten Faktoren prim sind, einbauen. So existiert zum Beispiel der Test nach Miller und Rabin, der zwar eigentlich probabilistisch ist, aber bei geschickter Implementierung deterministisch ist~\parencite{miller}. Außerdem wäre es noch interessant, inwiefern der erste Zerlegungsschritt dominant für die Laufzeit ist und wie lange die weiteren Zerlegungen brauchen. \\
Des Weiteren kann noch überprüft werden, welche Primzahlen man in der Praxis maximal zerlegen könnte. Dazu könnte man das Programm mit Techniken wie MPI (Message Passing Interface) auf mehrere Knoten eines Clusters zu verteilen, da sich der Code gut parallelisieren lässt.

\vfill
Der Programm-Code der erstellten Programme, die erzeugten Daten und die Arbeit selbst sind zu finden unter:\\
\url{https://github.com/f-koehler/bachelor-thesis}
