\chapter{Untersuchung des Verfahrens}\label{ch:results}

\section{Implementierung}
Es wurden im wesentlichen $3$ Programme implementiert.  \\
Das Programm \textit{onestep} führt einen Schritt der Faktorisierung einer Zahl durch, bildet also Algorithmus~\ref{alg:factorize} ab. \\
Mit dem Programm \textit{factorize} kann die komplette Faktorisierung einer Zahl berechnet werden. Es führt also den Algorithmus~\ref{alg:factorize} an der Zahl $N$ aus. Anschließend wird durch vergleich mit einer Liste vom Primzahlen überprüft, ob die erhaltenen Faktoren prim sind. Ist dies nicht der Fall wird der Algorithmus auf die entsprechenden Faktoren angewendet, bis die komplette Zerlegung ermittelt wurde. \\
Das Programm \textit{semiprime} bekommt zwei Primfaktoren $A$ und $B$ übergeben und berechnet das Produkt $N=A\cdot B$, welches folglich eine Semiprimzahl ist. Hier werden $a, a_1, b, b_1$ fest gewählt, weil sie über die Faktoren $A,B$ festgelegt werden. Dann werden $N_a$ Annealing-Schritte durchgeführt mit jeweils $N_c$ Konfigurationen/Metropolis-Schritten. Es soll hauptsächlich der Einfluss der Boltzmann-Konstanten auf das Verfahren untersucht werden. Diese muss variiert werden um die Skalierung der Energie auszugleichen, siehe Abschnitt~\ref{sec:kbguess}. \\
Beim Programmdurchlauf werden jeweils die Laufzeit, der Erfolgsrate und die Anzahl der benötigten Metropolis-Schritte. \\
Die angewendete Methode ist nicht-deterministisch und führt somit nicht immer zum gewünschten Ergebnis. Da die Probe bei allen $3$ Programmen effizient durchführbar ist, wird bei jedem Durchlauf der Erfolg oder Misserfolg gespeichert. Daraus kann die Erfolgsrate durch Division der Anzahl der erfolgreichen Versuche durch die Anzahl der Aufrufe berechnet werden. \\
Beim Programm \textit{semiprime} ist die Anzahl der Schritte im Falle eines Misserfolgs $N_a\cdot N_c$ ansonsten eine kleinere Anzahl. Beim Programm \textit{onestep} ist die Anzahl der Schritte bei Misserfolg durch Gl.\eqref{eq:runtime-theo-opt} gegeben.\\
Für die Implementierung des Verfahrens wurde die Programmiersprache C++ verwendet. Alle Programme bieten die Möglichkeit zur Verwendung von Threads also der parallelen Programausführung, vgl. Abschnitt~\ref{sec:parallel}. Dabei kommt die Thread-Bibliothek aus dem aktuellen C++ Standard~\parencite{cppthreads} zum Einsatz. \\
Die Programme liefen auf einem Knoten mit $8$ Kernen des Phido-Clusters der Fakultät Physik der TU Dortmund sowie einem privaten Rechner mit $8$ Kernen.

\section{\texorpdfstring{Abschätzung von $\bm{k_\mathrm{B}}$}{Abschätzung von kB}}\label{sec:kbguess}
Bei allen Untersuchungen wurde hier las zu maximierende Kostenfunktion
\begin{equation*}
		E\left(A,B,N\right)=\sum\limits_{i=1}^n\begin{cases}
    i^2 & \mathrm{falls}\:{\left\{A\cdot B\right\}}_i={\left\{N\right\}}_i \\
	0 & \mathrm{sonst}
  \end{cases}
\end{equation*}
gewählt. Der maximale Wert dieser Funktion ist eine quadratische Pyramidalzahl~\parencite{oeis}, also
\begin{equation*}
		E_{\mathrm{\max}}\left(n\right)=\sum\limits_{i=1}^n i^2=\frac{1}{3}n^3+\frac{1}{2}n^2+\frac{1}{6}n,\label{eq:kbguess}
\end{equation*}
sodass die Energie mit $\mathcal{O}\left(n^3\right)$ skaliert. \\
Es ist wichtig $k_\mathrm{B}$ geeignet zu wählen, weil dieser Paramter die Wahrscheinlichkeit bestimmt, mit der der Metroplisalgorithmus energetisch ungünstigere Konfigurationen akzeptiert. Kennt man für ein $\tilde{n}$ einen guten Wert $\tilde{k}_\mathrm{B}$ so kann man nach
\begin{equation*}
		k_\mathrm{B}=\frac{E_{\mathrm{\max}}\left(n\right)}{E_{\mathrm{\max}}\left(\tilde{n}\right)}\tilde{k}_\mathrm{B}
\end{equation*}
eine Abschätzung bei beliebiger Zahlenlänge $n$ für die zu wählende Boltzmann-Konstante treffen. \\
Das Experimentieren mit verschiedenen Werten hat gezeigt, dass bei $n=33$ eine Boltzmannkonstante $\tilde{k}_\mathrm{B}\approx 8^3=512$ zu guten Erfolgsraten führt. \\
Außerdem wurde das Programm \textit{semiprime} verwendet gezielt nach einem optimalen Wert für $k_B$ zu suchen. Dabei wurden zwei Primzahlen $A=66889$ und $B=104723$ gewählt, welche die Semiprimzahl $N=A\cdot B=7004816747$ mit $n=33$ ergeben und das Programm für verschiedene Werte $1^3\leq k_\mathrm{B}\leq 16^3$ aufgerufen. Jeder Durchlauf wurde dabei $4800$-mal wiederholt. Die dabei ermittelte Erfolsgrate bzw.\ die Programmlaufzeiten sind in Abb.~\ref{fig:kbguess-success} bzw.~\ref{fig:kbguess-runtime} grafisch dargestellt.\\
Es ist deutlich erkennbar, dass eine zu niedriger Wert von $k_\mathrm{B}$ zu Erfolgsraten nahe $0$ führt, also nur die wenigsten Programmaufrufe die Primfaktoren $A,B$ finden. Für den Erfahrungswert $k_\mathrm{B}\approx 8^3$ ergibt sich bereits eine gute Erfolgsrate von $30\%$. Besser scheint es jedoch $k_\mathrm{B}=15^3$ zu wählen, was hier einer Erfolgsrate von ca. $\SI{45}{\percent}$ entspricht. \\
Dieses Verhalten spiegelt sich auch in der Programmlaufzeit wieder. Zu beginn ist diese nahezu konstant, da kaum Durchläufe die gesuchten Faktoren finden und dadurch $N_c\cdot N_a$ Schritte durchlaufen werden. Mit steigender Erfolgsrate nimmt die Laufzeit ab und bei $k_\mathrm{B}=15^3$ wird ein Minimum erreicht. \\
Es wäre also günstiger gewesen in der Formel~\eqref{eq:kbguess} $\tilde{k}_\mathrm{B}=15^3=3375$ für $\tilde{n}$ zu wählen. In den nachfolgenden Untersuchungen konnte dies jedoch nicht berücksichtigt werden, da diese Erkenntnis erst sehr spät gemacht werden. In allen weiteren Simulationen wurde $\tilde{k}_\mathrm{B}=8^3=512$ gesetzt, um automatisch Werte der Boltzmann-Konstanten in Abhängigkeit der Länge $n$ der zu faktorisierenden Zahl zu ermitteln.
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.35\textheight]{plot/kbguess/success.pdf}
		\caption{Erfolgsrate bei der Suche nach einem optimalen Wert für $k_\mathrm{B}$}\label{fig:kbguess-success}
\end{figure}
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.35\textheight]{plot/kbguess/time.pdf}
		\caption{Laufzeiten bei der Suche nach einem optimalen Wert für $k_\mathrm{B}$}\label{fig:kbguess-runtime}
\end{figure}

\section{Analyse eines einzelnen Zerlegungsschrittes}
Mit dem Program \textit{onestep} wurden einzelne Zerlegungsschritte untersucht und dafür zunächst zwei Sätze von Zahlen gewählt. Zum einen wurden manuell für $n\in\left\{6,8,\dots,24\right\}$ je $10$ Semiprimzahlen konstruiert, sowie die drei Möglichen für $n=4$. Der andere Satz von Zahlen besteht aus beliebigen Zahlen, wobei für jedes $n\in\left\{8,9,\dots,32\right\}$ jeweils $15$ solcher Zahlen ausgesucht wurden. \\
Als Parameter wurden $N_a=500$, $N_c=1000$ und $F_c=0.997$ gewählt. Bei den Semiprimzahlen wurde jede Zerlegung $20$-mal durchgeführt, bei den beliebigen Zahlen auf Grund des größeren Datensatzes nur $10$-mal. \\
Die dabei ermittelten Erfolgsraten wurden in Abb.~\ref{fig:runtime-success} und Abb.~\ref{fig:runtime2-success} dargestellt. \\
In beiden Fällen erkennt man, dass die Erfolgsrate mit zunehmendem $n$ merklich abnimmt. Dies liegt daran, dass mit wachsendem $n$ auch der Bereich, in dem $a$, $a_1$, $b$ und $b_1$ liegen können wächst und zwar mit $\mathcal{O}\left(n^4\right)$ (siehe Abschnitt~\ref{sec:runtime-theo}).
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.35\textheight]{plot/runtime/success.pdf}
		\caption{Erfolgsrate bei der Zerlegung von Semiprimzahlen}\label{fig:runtime-success}
\end{figure}
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.35\textheight]{plot/runtime2/success.pdf}
		\caption{Erfolgsrate bei der Zerlegung von beliebigen Zahlen}\label{fig:runtime2-success}
\end{figure}
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.35\textheight]{plot/runtime/time.pdf}
		\caption{Laufzeiten bei der Zerlegung von Semiprimzahlen}\label{fig:runtime-runtime}
\end{figure}
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.35\textheight]{plot/runtime2/time.pdf}
		\caption{Laufzeiten bei der Zerlegung von beliebigen Zahlen}\label{fig:runtime2-runtime}
\end{figure}

\section{Laufzeitverhalten bei kompletter Zerlegung}
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.35\textheight]{plot/dummy/dummy.pdf}
\end{figure}
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.35\textheight]{plot/dummy/dummy.pdf}
\end{figure}

\section{Parallelisierbarkeit}\label{sec:parallel}
Wie in~\ref{alg:factorize} ersichtlich sind die Berechnungen für die Tupel $\left(a, b, a_1, b_1\right)$ unabhängig voneinander. Dies bietet Möglichkeiten zur Parallelisierung.
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.35\textheight]{plot/dummy/dummy.pdf}
\end{figure}
