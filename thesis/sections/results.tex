\chapter{Untersuchung des Verfahrens}

\section{Implementierung}
Für die Implementierung des Verfahrens wurde die Programmiersprache \textit{C++} verwendet. Zur Parallelisierung wurden die vom \textit{C++11}-Standard spezifizierte Thread-Klasse verwendet.

\section{\texorpdfstring{Abschätzung von $\bm{k_\mathrm{B}}$}{Abschätzung von kB}}
Bei allen Untersuchungen wurde hier die zu maximierende Kostenfunktion
\begin{equation*}
		E\left(A,B,N\right)=\sum\limits_{i=1}^n\begin{cases}
    i^2 & \mathrm{falls}\:{\left\{A\cdot B\right\}}_i={\left\{N\right\}}_i \\
	0 & \mathrm{sonst}
  \end{cases}
\end{equation*}
gewählt. Der maximale Wert dieser Funktion ist eine quadratische Pyramidazahl~\parencite{oeis}, also
\begin{equation*}
		E_{\mathrm{max}}\left(n\right)=\sum\limits_{i=1}^n i^2=\frac{1}{3}n^3+\frac{1}{2}n^2+\frac{1}{6}n,
\end{equation*}
sodass die Energie mit $\mathcal{O}\left(n^3\right)$ skaliert. \\
Es ist wichtig $k_\mathrm{B}$ geeignet zu wählen, weil dieser Paramter die Wahrscheinlichkeit bestimmt, mit der der Metroploisalgorithmus energetisch ungünstigere Konfigurationen akzeptiert. Kennt man für ein $\tilde{n}$ einen guten Wert $\tilde{k}_\mathrm{B}$ so kann man nach
\begin{equation*}
		k_\mathrm{B}=\frac{E_{\mathrm{max}}\left(n\right)}{E_{\mathrm{max}}\left(\tilde{n}\right)}\tilde{k}_\mathrm{B}
\end{equation*}
eine Abschätzung für die zu wählende Boltzmann-Konstante treffen. \\
Das Experimentieren mit verschiedenen Werten hat gezeigt, dass bei $n=33$ eine Boltzmannkonstante $\tilde{k}_\mathrm{B}=512$ zu guten Erfolgsraten führt.

\section{Laufzeitverhalten bei Semiprimzahlen}
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.3\textheight]{plot/runtime/success.pdf}
\end{figure}
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.3\textheight]{plot/runtime/time.pdf}
\end{figure}
\begin{figure}[ht]
		\centering
		\includegraphics[height=0.3\textheight]{plot/runtime/steps.pdf}
\end{figure}

\section{Laufzeitverhalten bei kompletter Zerlegung}

\section{Parallelisierbarkeit}
Wie in~\ref{alg:factorize} ersichtlich sind die Berechnungen für die Tupel $\left(a, b, a_1, b_1\right)$ unabhängig voneinander. Dies bietet Möglichkeiten zur Parallelisierung.
