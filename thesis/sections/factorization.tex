\chapter{Beschreibung des Verfahrens}

\section{Simulated Annealing}
Simulated Annealing~\parencite{nr} ist eine Methode, um Optimierungsprobleme zu lösen. Dieses Verfahren bietet sich an, wenn das Problem sehr komplex ist. Dies ist der Fall wenn für die Parameter ein großer Wertebereich zulässig ist, die Dimensionalität des Problems, d.h.\ die Anzahl der Parameter, hoch ist oder es neben dem gesuchten globalen Extremum noch viele lokale Extrema gibt. \\
Zu einer gegebenem Temperatur wird eine adäquate Anfangskonfiguration gewählt, z.B.\ bei einer hohen Temperatur eine zufällige Konfiguration. Dann werden Annealing Schritte ausgeführt, d.h.\ die Temperatur sukzessive gesenkt und dabei die Konfiguration leicht modifiziert. Eine solche Modifikation wird gemäß eines Metropolisalgorithmus akzeptiert. Verringert die neue Konfiguration die Energie respektive eine analog dazu definierte Kostenfunktion, so wird die Änderung akzeptiert ansonsten nur mit einer Wahrscheinlichkeit von $p=\exp\left(-\frac{\Delta E}{k_\mathrm{B}T}\right)$.

\section{Primfaktorzerlegung}
Die kanonische Primfaktorzerlegung bezeichnet die eindeutige Darstellung einer Zahl $N\in\mathbb{N}$ durch
\begin{equation*}
  N=\prod\limits_{i=1}^M p_i^{m_i},
\end{equation*}
wobei die $p_i\in\mathbb{N}$ mit $p_i>1$ Primzahlen und die $m_i\in\mathbb{N}$ die zugehörigen Exponenten sind.\\
Diese Zerlegung kann rekursiv aufgebaut werden. So wird zunächst die Zahl $N$ in zwei Faktoren $A$ und $B$ zerlegt, wobei $A,B\in\mathbb{N}$ nicht zwangsläufig Primfaktoren sind. Danach werden $A$ und $B$ zerlegt sofern sie nicht prim sind.\\
Es soll ein Verfahren entwickelt werden, dass die Zerlegung $N=A\cdot B$ mit $A\geq B$ berechnet.\\
Die Zahlen $N,A,B$ werden im Dualsystem ohne führende Nullen dargestellt, wobei $n, a, b$ die Anzahl der Stellen im $2$er-System seien. Die Faktoren $A, B$ können maximal die gleiche Länge haben wie $N$.
\begin{equation*}
		a_\mathrm{max}=b_\mathrm{max}=n
\end{equation*}
Bei der Multiplikation gilt dann entweder $a+b=n$ oder $a+b=n+1$. Hieraus kann man eine untere Schranke für $a$ gewinnen, es gilt:
\begin{equation*}
		a=n-b \:\vee\: a=n-b+1
\end{equation*}
Dieser Ausdruck wir minimal für das maximale $b \leq a$ mit $a,b>1$, also $a=b$.
\begin{equation*}
		a_\mathrm{min}=\begin{cases}
						2 & \mathrm{falls}\:\lf\frac{n}{2}\rf = 1 \\
						\lf\frac{n}{2}\rf & \mathrm{sonst}
				\end{cases}.
\end{equation*}
Die untere Schranke für $b$ ist bei gegebenem $a$
\begin{equation*}
		b_\mathrm{min}=\begin{cases}
						2 & \mathrm{falls}\:n-a=1 \\
						n-a & \mathrm{sonst}
				\end{cases}
\end{equation*}
Es werden nun noch zwei Zahlen $a_1, b_1\in\mathbb{N}$ eingeführt, die die Anzahl der $1$en in der binären Representation der Zahlen $A, B$ angibt. Es gilt dann:
\begin{align*}
		1\leq a_1\leq a \\
		1\leq b_1\leq b
\end{align*}
Die Kostenfunktion ist durch
\begin{equation*}
		E\left(A,B,N\right)=\sum\limits_{i=1}^n\begin{cases}
		  		f\left(i\right) & \mathrm{falls}\:{\left\{A\cdot B\right\}}_i={\left\{N\right\}}_i \\
						0 & \mathrm{sonst}\\
				\end{cases}
\end{equation*}
gegeben. Dabei ist ${\left\{N\right\}}_i$ die $i$-te Stelle der binären Repräsentation der Zahl $N$, wobei $i=0$ das niederwertigste Bit ist. $f\left(i\right)$ ist eine monoton steigende Funktion, z.B. $f\left(i\right)=i$ oder $f\left(i\right)=i^2$. Die Energie wächst mit der Übereinstimmung des Produktes $A\cdot B$ mit $N$, wobei die höherwertigen Bits ein größeres Gewicht haben. Bei dieser Energiedefinition gilt es also ein Maximum zu finden. \\
Für das Simulated Annealing wird für jedes $4$-Tupel $\left(a,b,a_1,b_1\right)$ mit einer Temperatur $T_0=1$ begonnen. Es werden dann $N_a$ Annealing-Schritte durchgeführt und bei jedem das System um einen Faktor $F_c$ abgekühlt, also $T_{i+1}=F_c\cdot T_i$. Vor jedem abkühlen werden $N_c$ Konfiguration getestet. Dies wird mit Hilfe eines Metropolis-Algorithmus~\parencite{metropolis} realisiert. \\
Zunächst sollen einige notwendige, grundlegende Operationen zur Modifikation von binären Zahlen eingeführt werden. Diese lassen die Länge der der Binärzahl und die Anzahl der auf $1$ bzw. $0$ gesetzten Bits invariant.
\begin{itemize}
		\item \textbf{swap:} Es werden zwei Bits zufällig vertauscht, wovon eines eine $1$ und eines eine $0$ ist.
		\item \textbf{slide:} Es wird eine durchgängige Sequenz an Bits zufällig ausgewählt und das Bit ganz rechts entfernt. Danach werden alle anderen Bits nach rechts durchgeschoben und das entfernte Bit hinten wieder eingefügt.
		\item \textbf{reverse:} Es wird eine zufällige Sequenz an Bits ausgewählt und ihre Reihenfolge invertiert.
		\item \textbf{random:} Es werden Bits zufällige ausgewählt und zufällig permutiert.
\end{itemize}
Der Ablauf eines Metropolisschrittes ist in Algorithmus~\ref{alg:metropolis} dargestellt. Es wird mit der Funktion $\mathrm{\textit{randomOperation}}\left(\right)$ zufällig eine der Operationen ausgewählt und durchgeführt. Danach wird die Energie $E^\prime$ der daraus resultierenden neuen Konfiguration berechnet. Die Akzeptanzwahrscheinlichkeit für die neue Konfiguration ist
\begin{equation*}
		p=\min\left\{1,\;\exp\left(-\frac{E^\prime-E}{k T_i}\right)\right\}.
\end{equation*}
Eine neue Konfiguration wird also akzeptiert, wenn sie die Energie vergrößert, ansonsten mit einer über einen Boltzmann-Faktor gegebene Wahrscheinlichkeit. \\
\input{./pseudocode/metropolis.tex}
\FloatBarrier{}

Für jedes $4$-Tupel $\left(a,b,a_1,b_1\right)$ werden $N_a$ Annealing-Schritte durchgeführt. Dies geschieht wie in Algorithmus~\ref{alg:anneal} dargestellt.
\input{./pseudocode/anneal.tex}
\FloatBarrier{}

Für die Zerlegung einer Zahl in zwei Faktoren müssen noch alle Tupel $\left(a,b,a_1,b_1\right)$ durchlaufen werden. Dies ist in Algorithmus~\ref{alg:factorize} dargestellt,
\input{./pseudocode/factorize.tex}
\FloatBarrier{}
\begin{equation*}
		n\cdot\left(n-1\right)\cdot n\cdot\left(n-1\right)\cdot N_a\cdot N_c\approx n^4\cdot N_a\cdot N_c
\end{equation*}
